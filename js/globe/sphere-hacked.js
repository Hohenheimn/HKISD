(function () { 'use strict'; function t (t) { i = document.createElement('canvas'), s = t.naturalWidth, h = t.naturalHeight, i.width = s, i.height = h, a = i.getContext('2d'), a.clearRect(0, 0, h, s), a.drawImage(t, 0, 0), o = a.getImageData(0, 0, h, s), g = Y / e, P = I / e } var n, i, a, e, r, o, s, h, u, f, l, c, m, v, M, x, d, g, P, p = {horizontal: 1, vertical: 1}, X = 0, y = 1, w = 2, Y = 30, I = 30, C = [0, 0, 0], F = [0, 30, 0], R = 12, A = 30, D = 0, E = C[X] - F[X], T = C[y] - F[y], S = C[w] - F[w], z = C[X] * C[X] + F[X] * F[X] + C[y] * C[y] + F[y] * F[y] + C[w] * C[w] + F[w] * F[w] - 2 * (C[X] * F[X] + C[y] * F[y] + C[w] * F[w]) - R * R, B = 4 * z, b = 0, q = 0.5 * Y, H = 0.5 * I, W = new Array(3), j = new Array(3), k = A * A, G = {}, J = function (t, n) { if (W[X] = g * t - q, W[w] = P * n - H, v = W[X] * W[X] + k + W[w] * W[w], d = x - v * B, d > 0) { b = (-M - Math.sqrt(d)) / (2 * v), j[X] = b * W[X], j[y] = T + b * W[y], j[w] = b * W[w]; var i = j[X], a = Math.sin(m), e = Math.cos(m); j[X] = i * e - j[y] * a, j[y] = i * a + j[y] * e; var r; r = j[w]; var o = Math.sin(c), u = Math.cos(c); j[w] = r * u - j[y] * o, j[y] = r * o + j[y] * u; var f = s + s * (Math.atan2(j[y], j[X]) + Math.PI) / (2 * Math.PI), l = s * Math.floor(h - 1 - h * (Math.acos(j[w] / R) / Math.PI) % h); return {lv: l, lh: f} } return null }, K = function () { var t, i = o.data, a = r.data; t = a.splice ? function (t, n) { a.splice(t, 4, i[n + 0], i[n + 1], i[n + 2], 255) } : function (t, n) { a[t + 0] = i[n + 0], a[t + 1] = i[n + 1], a[t + 2] = i[n + 2], a[t + 3] = 255 }; var v = (function () { var t = new Array(e * e); return function (n) { if (void 0 === t[n]) { var i = Math.floor(n / e), a = n - i * e; t[n] = J(a, i) } return t[n] } }()), M = 0.2 * s / 2e4, x = {fastCount: 0, fastSumMs: 0}; return {posDelta: M, firstFramePos: new Date() * M, positionsCache: [], minX: null, minY: null, maxX: null, maxY: null, init: function (n) { this.changeRotation(n), Y = 30, I = 30, C = [0, 0, 0], F = [0, 30, 0], R = n.r, A = 30, E = C[X] - F[X], T = C[y] - F[y], S = C[w] - F[w], z = C[X] * C[X] + F[X] * F[X] + C[y] * C[y] + F[y] * F[y] + C[w] * C[w] + F[w] * F[w] - 2 * (C[X] * F[X] + C[y] * F[y] + C[w] * F[w]) - R * R, B = 4 * z, b = 0, q = 0.5 * Y, H = 0.5 * I, j = new Array(3), k = A * A, G = {}, t = a.splice ? function (t, n) { a.splice(t, 4, i[n + 0], i[n + 1], i[n + 2], 255) } : function (t, n) { a[t + 0] = i[n + 0], a[t + 1] = i[n + 1], a[t + 2] = i[n + 2], a[t + 3] = 255 }, M = 0.2 * s / 2e4, x = {fastCount: 0, fastSumMs: 0}, v = (function () { var t = new Array(e * e); return function (n) { if (void 0 === t[n]) { var i = Math.floor(n / e), a = n - i * e; t[n] = J(a, i) } return t[n] } }()) }, renderFrame: function (t) { return void this.RF(t) }, sumRF: function (t) { this.RF(t), x.fastSumMs += new Date() - t, x.fastCount++, x.fastSumMs > x.firstMs && (this.renderFrame = this.RF) }, turnBy: function (t) { return 86400 + this.firstFramePos - t * this.posDelta }, changeRotation: function (t) { c = 90 + t.tilt, m = 180 + t.turn, u = 90 - c, f = 180 - m, D = 0, f }, getRadius: function () { return this.minX === null ? null : (this.maxX - this.minX + (this.maxY - this.minY)) / 2 }, getTexturePointPosition: function (t, n) { for (var i = 30, a = 0; i > a; a++) { var e, r, o; for (e = t - a; t + a + 1 > e; e++) { if (r = n - a, o = this.getTexturePointPositionExact(e, r), typeof o !== 'undefined') return o; if (r = n + a, o = this.getTexturePointPositionExact(e, r), typeof o !== 'undefined') return o } for (r = n - a + 1; n + a > r; r++) { if (e = t - a, o = this.getTexturePointPositionExact(e, r), typeof o !== 'undefined') return o; if (e = t + a, o = this.getTexturePointPositionExact(e, r), typeof o !== 'undefined') return o } } }, getTexturePointPositionExact: function (t, n) { var i = this.positionsCache[t + n * s]; return typeof i === 'undefined' ? i : {x: i % e, y: Math.floor(i / e), pixel: i, originalX: t, originalY: n} }, RF: function (t) { l = D * Math.PI / 180, c = u * Math.PI / 180, m = f * Math.PI / 180; var o = this.turnBy(t), M = e * e, x = h * h; for (this.positionsCache = new Array(x), this.minX = null, this.minY = null, this.maxX = null, this.maxY = null; M--;) { var d = v(M); if (d !== null) { var g = M % e, P = Math.floor(M / e); this.minX == null ? (this.minX = g, this.maxX = g, this.minY = P, this.maxY = P) : (this.minX > g && (this.minX = g), this.maxX < g && (this.maxX = g), this.minY > P && (this.minY = P), this.maxY < P && (this.maxY = P)); var X = Math.floor(d.lh * p.horizontal + o * p.horizontal) % s, y = 4 * M, w = 4 * (X + d.lv * p.vertical % x); this.positionsCache[Math.floor(w / 4)] = Math.floor(y / 4), a[y + 0] = i[w + 0], a[y + 1] = i[w + 1], a[y + 2] = i[w + 2], a[y + 3] = 255 } }n.putImageData(r, 0, 0) }} }; this.createSphere = function (i, a, o, u) { e = Math.min(i.width, i.height), n = i.getContext('2d'), r = n.createImageData(e, e), p = u, g = Y / e, P = I / e, W[y] = A, M = 2 * (-A * W[y]), x = Math.pow(M, 2); var f = new Image(); f.onload = function () { t(f); var n = K(); o(n, s, h) }, f.setAttribute('src', a) } }).call(this)
